function modelfiles=getmodelfilenames(ocStruct,varargin)

excludeidx=find(strcmpi(varargin,'exclude'));
includeidx=find(strcmpi(varargin,'include'));
onlyidx=find(strcmpi(varargin,'only'));
if ~isempty(excludeidx)
    excludefiles=varargin{excludeidx+1};
    if ischar(excludefiles)
        excludefiles={excludefiles};
    end
end
if ~isempty(includeidx)
    includefiles=varargin{includeidx+1};
    if ischar(includefiles)
        includefiles={includefiles};
    end
end
if ~isempty(onlyidx)
    onlyfiles=varargin{onlyidx+1};
    if ischar(onlyfiles)
        onlyfiles={onlyfiles};
    end
end

switch modeltype(ocStruct)
    case 'standardmodel'
        % 0 symbolic standard notation depvar1,depvar2,...,ctrl1,ctrl2,...
        % 1 vector notation depvar(1),depvar(2),...,ctrl(1),ctrl(2),...
        % 2 vectorized notation depvar(1,:),depvar(2,:),...,ctrl(1,:),ctrl(2,:),...
        % 3 user notation
        optmethod=optimizationmethod(ocStruct);
        description='';
        for ii=1:size(optmethod,1)
            switch deblank(optmethod(ii,:))
                case 'bvp'
                    bvpdescription={'ArcInfo'; 0; ...
                        'ArcDiscretizationInfo'; 0; ...
                        'CanonicalSystem'; 2; ...
                        'EquilibriumEquation'; 2; ...
                        'EquilibriumAdmissible'; 2; ...
                        'SymbolicCanonicalSystem'; 3; ...
                        'CanonicalSystemJacobian'; 1; ...
                        'EquilibriumEquationJacobian'; 1; ...
                        'SymbolicEquilibriumEquation'; 3; ...
                        'SymbolicCanonicalSystemJacobian'; 3; ...
                        'CanonicalSystemParameterJacobian'; 1; ...
                        'EquilibriumEquationParameterJacobian'; 1; ...
                        'OptimalControl'; 2; ...
                        'SymbolicOptimalControl'; 3; ...
                        'LagrangeMultiplier'; 2; ...
                        'SymbolicLagrangeMultiplier'; 3; ...
                        'Hamiltonian'; 2; ...
                        'DHamiltonianDx'; 2; ...
                        'DHamiltonianDu'; 2; ...
                        'D2HamiltonianDu2'; 1; ...
                        'D2HamiltonianDX2'; 1; ...
                        'SymbolicHamiltonian'; 3; ...
                        'SymbolicLagrangian'; 3; ...
                        'SymbolicObjectiveFunction'; 3; ...
                        'BCJacobian4Initial'; 1; ...
                        'BCJacobian4Asymptotic'; 1; ...
                        'BCJacobian4Guard'; 1; ...
                        'BCJacobian4Reset';1; ...
                        'Admissible';0; ...
                        'UserAdmissible';2; ...
                        'UserFunction';2; ...
                        'ObjectiveFunction';2; ...
                        'ObjectiveFunctionJacobian'; 1; ...
                        'ObjectiveFunctionParameterJacobian'; 1; ...
                        'ObjectiveFunctionDerivativeTime'; 2; ...
                        'Constraint';2; ...
                        'SymbolicConstraint';3; ...
                        'Salvagevalue';1; ...
                        'DiscountedSalvagevalue';1; ...
                        'TransversalityBC';1; ...
                        'PlotIndifferenceContinuation';0; ...
                        'PlotContinuation';0};
                    if stateconstraint(ocStruct)
                        bvpdescription=[bvpdescription; ...
                            {'4SaddlePathContinuationWithStateConstraints'; 1; ...
                            '4IndifferenceSolutionContinuationWithStateConstraints'; 1; ...
                            '4FiniteHorizonPathContinuationWithStateConstraints'; 1; ...
                            'StateConstraintTotalTimeDerivative'; 1; ...
                            'StateConstraintEdgeType'; 0; ...
                            'StateConstraintBC';1; ...
                            'State'; 2; ...
                            'SymbolicState'; 3}];
                    else
                        bvpdescription=[bvpdescription; ...
                            {'4SaddlePathContinuation'; 1; ...
                            '4FiniteHorizonPathContinuation'; 1; ...
                            '4IndifferenceSolutionContinuation'; 1}];
                    end
                    if ~isautonomous(ocStruct)
                        bvpdescription=[bvpdescription; ...
                            {'CanonicalSystemDerivativeTime'; 2}];
                    end
                    if isempty(description)
                        description=bvpdescription;
                    else
                        description=[description; ...
                            bvpdescription];
                    end
                    if ocStruct.variable.state.num>10
                        ocmatmsg('The number of states is %d.\n',ocStruct.variable.state.num)
                        answer=input('Generating the files for the Hessian can therefore take hours. Generate Hessians?  y/(n): ','s');
                        if isempty(answer)
                            % default value 'n'
                            answer='n';
                        end
                        if strcmpi(answer,'y')
                            makehess=true;
                        else
                            makehess=false;
                        end
                    else
                        makehess=true;
                    end
                    if makehess
                        description=[description; ...
                            {'CanonicalSystemHessian'; 1; ...
                            'CanonicalSystemTotalHessian'; 1}];
                    end

                    if ocStruct.variable.state.num>1
                        if ~isautonomous(ocStruct)
                            description=[description; ...
                                {'4PeriodicSolutionContinuation'; 1}];
                        else
                            description=[description; ...
                                {'4LimitCycleContinuation'; 1}];
                        end
                    end
%                     if implicitcontrols(ocStruct)
%                         description=[description; ...
%                             {'OptimalControlImplicit'; 2; ...
%                             'CanonicalSystemImplicit'; 2; ...
%                             'CanonicalSystemExplicit'; 2; ...
%                             'CanonicalSystemGeneralized';2; ...
%                             'CanonicalSystemAE'; 2; ...
%                             'CanonicalSystemImplicitJacobian'; 1; ...
%                             'CanonicalSystemImplicitNumericalJacobian'; 1; ...
%                             'CanonicalSystemImplicitNumericalParameterJacobian'; 1; ...
%                             'DGeneralizedControlDX'; 2; ...
%                             'OptimalControlDynamics';2; ...
%                             'SymbolicCanonicalSystemExplicit'; 3; ...
%                             'AlgebraicEquation'; 2'CanonicalSystemImplicitNumericalJacobian'; 1; ...
%                             'CanonicalSystemImplicitNumericalParameterJacobian'; 1; ...
%                             'DGeneralizedControlDX'; 2; ...
%                             'DImplicitControlDX'; 2; ...
%                             'D2PontryaginfunctionDuu'; 2; ...
%                             'GeneralizedGX'; 1; ...
%                             'GeneralizedGP'; 1; ...
%                             'GeneralizedGu'; 1; ...
%                             'ControlDynamicsJacobian'; 2; ...
%                             'ControlDynamicsJacobianParameter'; 2; ...
%                             'OptimalControlDynamics'; 2; ...
%                             'D2LagrangianDU2'; 2; ...
%                             'D2LagrangianDUDX'; 2; ...
%                             'D2LagrangianDUDP'; 2; ...
%                             'D2HamiltonianDui2'; 2; ...
%                             'D2HamiltonianDuiDX'; 2}];
%                     else
%                         description=[description; ...
%                             {'SpecificCanonicalSystem'; 2; ...
%                             'SpecificPontryaginFunction'; 2}];
%                     end
                    if implicitcontrols(ocStruct)
                        description=[description; ...
                            {'CanonicalSystemGeneralized';2; ...
                            'ImplicitControlDynamics'; 2; ...
                            'DLagrangianDU'; 2; ...
                            'D2LagrangianDU2'; 2; ...
                            'D2LagrangianDUDX'; 2; ...
                            'D2LagrangianDUDP'; 2; ...
                            'DImplicitControlDX'; 2; ...
                            'DImplicitControlDP'; 2; ...
                            'CanonicalSystemGeneralizedJacobian'; 1; ...
                            'CanonicalSystemGeneralizedParameterJacobian'; 1; ...
                            'ImplicitControlDynamicsJacobian'; 1; ...
                            'ImplicitControlDynamicsParameterJacobian'; 1; ...
                            'ImplicitG'; 2; ...
                            'ImplicitGX'; 1; ...
                            'ImplicitGU'; 1; ...
                            'ImplicitGP'; 1; ...
%                            'CanonicalSystemAE'; 2; ...
%                            'SymbolicCanonicalSystemExplicit'; 3; ...
                            'AlgebraicEquation'; 2; ...
                            'AlgebraicEquationJacobian'; 1; ...
                            'AlgebraicEquationParameterJacobian'; 1; ...
                            'AlgebraicEquationI'; 2
                            }];
                    else
                        description=[description; ...
                            {'SpecificCanonicalSystem'; 2; ...
                            'SpecificPontryaginFunction'; 2}];
                    end
                    if exogenousfunction(ocStruct)
                        description=[description; ...
                            {'ExogenousFunction'; 2; ...
                            'ExogenousJacobian'; 1; ...
                            'ExogenousParameterJacobian'; 1}];
                    end
                    if exogenousdynamics(ocStruct)
                        description=[description; ...
                            {'ExogenousDynamics'; 2; ...
                            'ExogenousDynamicsJacobian'; 1; ...
                            'ExogenousDynamicsParameterJacobian'; 1}];
                    end
                    if variationparameter(ocStruct)
                        description=[description; ...
                            {'VariationalDynamics'; 2; ...
                            'VariationalOptimalControl'; 2; ...
                            'VariationalObjectiveFunction'; 2; ...
                            'VariationalConstraint'; 1; ...
                            'VariationalNumericalJacobian'; 1; ...
                            'VariationalNumericalParameterJacobian'; 1; ...
                            'VariationalNumericalObjectiveFunctionJacobian'; 1; ...
                            'VariationalNumericalObjectiveFunctionParameterJacobian'; 1; ...
                            'VariationalHamiltonian'; 2; ...
                            'VariationalSalvageValue'; 1; ...
                            'VariationalTransversalityBC';1; ...
                            'VariationalStateConstraintBC';1}];
                        if exogenousfunction(ocStruct)
                            description=[description; ...
                                {'VariationalExogenousFunction'; 2}];
                        end
                    end

                    if nonsmoothfunction(ocStruct)
                        description=[description; ...
                            {'NonsmoothFunction'; 2; ...
                            'NonsmoothJacobian'; 1; ...
                            'NonsmoothParameterJacobian'; 1; ...
                            'SwitchingFunction'; 2}];
                    end
                case 'grad'
                    graddescription={'4GradContinuation'; 1; ...
                        'LocalStateDynamics';2; ...
                        'LocalCostateDynamics';2
                        'LocalObjectiveFunction';2; ...
                        'LocalDHamiltonian';2; ...
                        'LocalHamiltonian';2; ...
                        'LocalSalvagevalue';1; ...
                        'LocalTransversalityBC';1; ...
                        'LocalControlProjection';2; ...
                        'LocalConstraint';2; ...
                        'GradUserFunction';1; ...
                        'KuhnTuckerPoint';2; ...
                        'ControlBounds';2; ...
                        'PlotContinuation4Grad';1
                        };
                    if isempty(description)
                        description=graddescription;
                    else
                        description=[description; ...
                            graddescription];
                    end
                case 'dae'
                    daedescription={'4DAEContinuation'; 1; ...
                        'CanonicalSystemDAE';2; ...
                        'CanonicalSystemJacobianDAE';1; ...
                        'CanonicalSystemParameterJacobianDAE';1; ...
                        'ObjectiveFunctionDAE';2; ...
                        'ObjectiveFunctionJacobianDAE';1; ...
                        'ObjectiveFunctionParameterJacobianDAE';1; ...
                        'DLagrangeFunctionDuDAE';2; ...
                        'DLagrangeFunctionDuJacobianDAE';1; ...
                        'DLagrangeFunctionDuParameterJacobianDAE';1; ...
                        'ComplementarySlacknessDAE';2; ...
                        'ComplementarySlacknessJacobianDAE';1; ...
                        'ComplementarySlacknessParameterJacobianDAE';1; ...
                        'ConstraintDAE';2; ...
                        'SalvagevalueDAE';1; ...
                        'TransversalityBCDAE';1; ...
                        'PlotContinuationDAE';1
                        };
                    if isempty(description)
                        description=daedescription;
                    else
                        description=[description; ...
                            daedescription];
                    end
                    %%                         
            end
        end
        if ~isempty(includeidx)
            for ii=1:length(includefiles)
                description=[description; ...
                    {includefiles{ii};2}];
            end
        end
        removeidx=[];
        keepidx=[];
%         if transform2statecontrolspace(ocStruct)
%             description(1:2:end)=strrep(description(1:2:end),'CanonicalSystem','StateControlCanonicalSystem');
%             description(1:2:end)=strrep(description(1:2:end),'OptimalControl','OptimalControl4StateControl');
%             %description(1:2:end)=strrep(description(1:2:end),'EquilibriumEquation','EquilibriumEquation4StateControl');
%             %description(1:2:end)=strrep(description(1:2:end),'LagrangeMultiplier','LagrangeMultiplier4StateControl');
%             description=[description; ...
%                 {'Costate'; 2; ...
%                 'SymbolicCostate';3}];
%             idx=strfind(description(1:2:end),'SymbolicParameterJacobian');
%             for ii=1:length(idx)
%                 if ~isempty(idx{ii})
%                     removeidx=sort([removeidx (2*idx-1);2*idx]);
%                 end
%             end
%             idx=strfind(description(1:2:end),'Hessian');
%             for ii=1:length(idx)
%                 if ~isempty(idx{ii})
%                     removeidx=sort([removeidx (2*idx-1);2*idx]);
%                 end
%             end
%             idx=strfind(description(1:2:end),'Specific');
%             for ii=1:length(idx)
%                 if ~isempty(idx{ii})
%                     removeidx=sort([removeidx (2*idx-1);2*idx]);
%                 end
%             end
%         end
        if ~isempty(excludeidx)
            for ii=1:length(excludefiles)
                idx=find(strcmp(description(1:2:end),excludefiles{ii}));
                if length(idx)>1
                    for kk=1:length(idx)
                        removeidx=[removeidx [(2*idx(kk)-1);2*idx(kk)]];
                    end
                else
                    removeidx=[removeidx [(2*idx-1);2*idx]];
                end
            end
            removeidx=sort(removeidx);
        end
        if ~isempty(onlyidx)
            for ii=1:length(onlyfiles)
                idx=find(~cellfun('isempty',regexpi(description(1:2:end),onlyfiles{ii})));
                keepidx=sort([keepidx (2*idx-1);2*idx]);
            end
        end
        if ~isempty(removeidx)
            description(removeidx)=[];
        end
        if ~isempty(keepidx)
            description=description(keepidx);
        end

    case 'multistagemodel'
        % 0 symbolic standard notation depvar1,depvar2,...,ctrl1,ctrl2,...
        % 1 vector notation depvar(1),depvar(2),...,ctrl(1),ctrl(2),...
        % 2 vectorized notation depvar(1,:),depvar(2,:),...,ctrl(1,:),ctrl(2,:),...
        % 3 user notation
        description={'ArcInfo'; 0; ...
            'ArcDiscretizationInfo'; 0; ...
            'CanonicalSystem'; 2; ...
            'SymbolicCanonicalSystem'; 3; ...
            'CanonicalSystemJacobian'; 1; ...
            'SymbolicCanonicalSystemJacobian'; 3; ...
            'CanonicalSystemParameterJacobian'; 1; ...
            'OptimalControl'; 2; ...
            'SymbolicOptimalControl'; 3; ...
            'LagrangeMultiplier'; 2; ...
            'SymbolicLagrangeMultiplier'; 3; ...
            'Hamiltonian'; 2; ...
            'DHamiltonianDx'; 2; ...
            'D2HamiltonianDu2'; 2; ...
            'SymbolicHamiltonian'; 3; ...
            'SymbolicObjectiveFunction'; 3; ...
            'Admissible';0; ...
            'UserAdmissible';2; ...
            'UserFunction';2; ...
            'ObjectiveFunction';2; ...
            'ObjectiveFunctionJacobian'; 1; ...
            'ObjectiveFunctionParameterJacobian'; 1; ...
            'ObjectiveFunctionDerivativeTime'; 2; ...
            'Constraint';2; ...
            'Salvagevalue';1; ...
            'DiscountedSalvagevalue';1; ...
            'TransversalityBC';1; ...
            'PlotIndifferenceContinuation';0; ...
            'PlotContinuation';0; ...
            '4FiniteHorizonPathContinuation'; 1; ...
            '4IndifferenceSolutionContinuation'; 1; ...
            'ObjectiveFunctionDerivativeConnectionTime'; 2; ...
            'DiscountedSalvagevalueDerivativeConnectionTime';1};
        if ~isautonomous(ocStruct)
            description=[description; ...
                {'CanonicalSystemDerivativeTime'; 2}];
        end

        if explicitconnectiontime(ocStruct)
            description=[description; ...
                {'CanonicalSystemDerivativeConnectionTime'; 1; ...
                'DHamiltonianDct'; 2; ...
                'DHamiltonianDctJacobian'; 1; ...
                'DHamiltonianDctParameterJacobian'; 1; ...
                'DHamiltonianDctDerivativeTime';1; ...
                'D2HamiltonianDct2';1}];
        end

        if exogenousfunction(ocStruct)
            description=[description; ...
                {'ExogenousFunction'; 2; ...
                'ExogenousJacobian'; 1; ...
                'ExogenousParameterJacobian'; 1; ...
                'ExogenousCtJacobian'; 1}];
        end
        if ~isempty(includeidx)
            for ii=1:length(includefiles)
                description=[description; ...
                    {includefiles{ii};2}];
            end
        end
        removeidx=[];
        if ~isempty(excludeidx)
            for ii=1:length(excludefiles)
                idx=find(~cellfun('isempty',strfind(description(1:2:end),excludefiles{ii})));
                removeidx=[removeidx (2*idx-1):2*idx];
            end
        end
        description(removeidx)=[];


    case 'standarddiffmodel'
        % 0 symbolic standard notation depvar1,depvar2,...,ctrl1,ctrl2,...
        % 1 vector notation depvar(1),depvar(2),...,ctrl(1),ctrl(2),...
        % 2 vectorized notation depvar(1,:),depvar(2,:),...,ctrl(1,:),ctrl(2,:),...
        % 3 user notation
        description={'CanonicalSystemMap'; 2; ...
            'StateMap'; 2;  ...
            'StateMapJacobian'; 1; ...
            'OptimalControl'; 2; ...
            'CanonicalSystemMapJacobian'; 1; ...
            'CanonicalSystemMapParameterJacobian'; 1; ...
            'FixPointEquation'; 2; ...
            'LagrangeMultiplier'; 2; ...
            'Hamiltonian'; 2; ...
            'SymbolicOptimalControl'; 3; ...
            'SymbolicCanonicalSystemMap'; 3; ...
            'SymbolicLagrangeMultiplier'; 3; ...
            'SymbolicCanonicalSystemMapJacobian'; 3; ...
            'SymbolicHamiltonian'; 3; ...
            'BCJacobian4Initial'; 1; ...
            'BCJacobian4Asymptotic'; 1; ...
            'Admissible';0; ...
            'UserAdmissible';2; ...
            'UserFunction';2; ...
            'ObjectiveFunctionJacobian'; 2; ...
            'ObjectiveFunctionParameterJacobian'; 1; ...
            'Constraint';2; ...
            '4SaddlePathContinuation'; 1; ...
            '4IndifferenceSolutionContinuation'; 1; ...
            'ObjectiveFunction';2; ...
            'PlotContinuation';0};

    case 'odemodel'
        description={'ArcInfo'; 0; ...
            'ArcDiscretizationInfo'; 0; ...
            'Dynamics'; 2; ...
            'DynamicsJacobian'; 1; ...
            'DynamicsParameterJacobian'; 1; ...
            'EquilibriumEquation'; 2; ...
            'EquilibriumEquationJacobian'; 1; ...
            'SymbolicDynamics'; 3; ...
            'SymbolicDynamicsJacobian'; 3; ...
            'SymbolicDynamicsParameterJacobian'; 3; ...
            'SymbolicEquilibriumEquation'; 3; ...
            '4SaddlePathContinuation'; 1; ...
            '4Continuation'; 1; ...
            'UserFunction';2; ...
            'UserAdmissible';2; ...
            'PlotContinuation';0};

        if exogenousfunction(ocStruct)
            description=[description; ...
                {'ExogenousFunction'; 2; ...
                'SymbolicExogenousFunction'; 3}];
        end
    case 'impulsemodel'
        % 0 symbolic standard notation depvar1,depvar2,...,ctrl1,ctrl2,...
        % 1 vector notation depvar(1),depvar(2),...,ctrl(1),ctrl(2),...
        % 2 vectorized notation depvar(1,:),depvar(2,:),...,ctrl(1,:),ctrl(2,:),...
        % 3 user notation
        description={'ArcInfo'; 0; ...
            'ArcDiscretizationInfo'; 0; ...
            'CanonicalSystem'; 2; ...
            'EquilibriumEquation'; 2; ...
            'SymbolicCanonicalSystem'; 3; ...
            'CanonicalSystemJacobian'; 1; ...
            'EquilibriumEquationJacobian'; 1; ...
            'SymbolicEquilibriumEquation'; 3; ...
            'SymbolicCanonicalSystemJacobian'; 3; ...
            'CanonicalSystemParameterJacobian'; 1; ...
            'EquilibriumEquationParameterJacobian'; 1; ...
            'OptimalControl'; 2; ...
            'SymbolicOptimalControl'; 3; ...
            'LagrangeMultiplier'; 2; ...
            'SymbolicLagrangeMultiplier'; 3; ...
            'Hamiltonian'; 2; ...
            'DHamiltonianDx'; 2; ...
            'D2HamiltonianDu2'; 2; ...
            'SymbolicHamiltonian'; 3; ...
            'SymbolicObjectiveFunction'; 3; ...
            'BCJacobian4Initial'; 1; ...
            'BCJacobian4Asymptotic'; 1; ...
            'BCJacobian4Guard'; 1; ...
            'BCJacobian4Reset';1; ...
            'Admissible';0; ...
            'UserAdmissible';2; ...
            'UserFunction';2; ...
            'ObjectiveFunction';2; ...
            'ObjectiveFunctionJacobian'; 1; ...
            'ObjectiveFunctionParameterJacobian'; 1; ...
            'Constraint';2; ...
            'PlotIndifferenceContinuation';0; ...
            'PlotContinuation';0; ...
            '4GOdeCalc';2; ...
            '4SaddlePathContinuation'; 1; ...
            '4IndifferenceSolutionContinuation'; 1; ...
            'SymbolicSalvagevalue';3};

        % specific impulse files
        description=[description; ...
            {'ImpulseHamiltonian'; 1; ...
            'SymbolicImpulseHamiltonian'; 3; ...
            'OptimalImpulseControl'; 1; ...
            'SymbolicOptimalImpulseControl'; 3; ...
            'StateEvent';1; ...
            'AdjointEvent';1; ...
            'DImpulseHamiltonianDtau';1; ...
            'Salvagevalue';1; ...
            'TransversalityBC';1; ...
            'ImpulseObjectiveFunction';1; ...
            'SymbolicImpulseObjectiveFunction'; 3; ...
            'InteriorImpulseBC';1; ...
            'EventBC';1; ...
            '4FiniteImpulsePathContinuation';1; ...
            'DiscountedSalvagevalue';1; ...
            'DiscountedImpulseObjectiveFunction';1}];
        if ~isautonomous(ocStruct)
            description=[description; ...
                {'CanonicalSystemDerivativeTime'; 2; ...
                'ObjectiveFunctionDerivativeTime'; 2}];
        end


        if exogenousfunction(ocStruct)
            description=[description; ...
                {'ExogenousFunction'; 2}; ...
                {'D1ExogenousFunctionDx'; 2}];
        end
        if ~isempty(includeidx)
            for ii=1:length(includefiles)
                description=[description; ...
                    {includefiles{ii};2}];
            end
        end
        removeidx=[];
        if ~isempty(excludeidx)
            for ii=1:length(excludefiles)
                idx=find(~cellfun('isempty',strfind(description(1:2:end),excludefiles{ii})));
                removeidx=[removeidx (2*idx-1):2*idx];
            end
        end
        description(removeidx)=[];

    case 'ppdemodel'
        description={'Admissible';2; ...
            'CanonicalSystem'; 2; ...
            'CanonicalSystemJacobian'; 2; ...
            'CanonicalSystemJacobianNumerical'; 2; ...
            'Constraint';2; ...
            'EquilibriumEquation'; 2; ...
            'EquilibriumEquationJacobian'; 1; ...
            'Hamiltonian'; 2; ...
            'LagrangeMultiplier'; 2; ...
            'ObjectiveFunction';2; ...
            'ObjectiveFunctionJacobian'; 2; ...
            'ObjectiveFunctionParameterJacobian'; 2; ...
            'OOPDE1D'; 1; ...
            'PlotContinuation';0; ...
            'SymbolicCanonicalSystem'; 3; ...
            'SymbolicOptimalControl'; 3; ...
            'UserFunction';2; ...
            '4SaddlePathContinuation'; 1
            };

        % specific ppde model files
        %         description=[description; ...
        %             {'ImpulseHamiltonian'; 1; ...
        %             'SymbolicImpulseHamiltonian'; 3; ...
        %             'OptimalImpulseControl'; 1; ...
        %             'SymbolicOptimalImpulseControl'; 3; ...
        %             'StateEvent';1; ...
        %             'AdjointEvent';1; ...
        %             'DImpulseHamiltonianDtau';1; ...
        %             'Salvagevalue';1; ...
        %             'TransversalityBC';1; ...
        %             'ImpulseObjectiveFunction';1; ...
        %             'SymbolicImpulseObjectiveFunction'; 3; ...
        %             'InteriorImpulseBC';1; ...
        %             'EventBC';1; ...
        %             '4FiniteImpulsePathContinuation';1; ...
        %             'DiscountedSalvagevalue';1; ...
        %             'DiscountedImpulseObjectiveFunction';1}];
        if ~isautonomous(ocStruct)
            description=[description; ...
                {'CanonicalSystemDerivativeTime'; 2; ...
                'ObjectiveFunctionDerivativeTime'; 2}];
        end

        if ~isempty(nonspatialcontrol(ocStruct))
            description=[description; ...
                {'NonspatialOptimalControl'; 2}];
        end


        if ~isempty(spatialcontrol(ocStruct))
            description=[description; ...
                {'OptimalControl'; 2}];
        end


        if exogenousfunction(ocStruct)
            description=[description; ...
                {'ExogenousFunction'; 2}];
        end
        if ~isempty(includeidx)
            for ii=1:length(includefiles)
                description=[description; ...
                    {includefiles{ii};2}];
            end
        end
        removeidx=[];
        if ~isempty(excludeidx)
            for ii=1:length(excludefiles)
                idx=find(~cellfun('isempty',strfind(description(1:2:end),excludefiles{ii})));
                removeidx=[removeidx (2*idx-1):2*idx];
            end
        end
        description(removeidx)=[];

    case 'staticoptmodel'
        switch ocStruct.optimization.method
            case 'statgrad'
                description={'4GradContinuation'; 1; ...
                    'ObjectiveFunction'; 2;...
                    'GradientObjectiveFunction'; 1; ...
                    'GradientParObjectiveFunction'; 1; ...
                    'EqualityConstraint'; 2; ...
                    'InequalityConstraint'; 2; ...
                    'GradientEqualityConstraint'; 1; ...
                    'GradientInequalityConstraint'; 1; ...
                    'ParameterGradientInequalityConstraint'; 1; ...
                    'QPSolution'; 1; ...
                    'NesterovSolution'; 1; ...
                    'PlotContinuation'; 1; ...
                    'UserFunction';2};
            case 'semismooth'
                description={'4Continuation'; 1; ...
                    'ObjectiveFunction'; 2; ...
                    'LagrangeFunction'; 2; ...
                    'FirstOrderNC'; 1; ...
                    'HessianLagrangeFunction'; 1; ...
                    'ParameterHessianLagrangeFunction'; 1;...
                    'EqualityConstraint'; 2; ...
                    'Constraint'; 2; ...
                    'GradientEqualityConstraint'; 1; ...
                    'GradientConstraint'; 1; ...
                    'ParameterGradientConstraint'; 1;...
                    'PlotContinuation'; 1; ...
                    'UserFunction';2};
        end
    case 'differentialgame'
        % 0 symbolic standard notation depvar1,depvar2,...,ctrl1,ctrl2,...
        % 1 vector notation depvar(1),depvar(2),...,ctrl(1),ctrl(2),...
        % 2 vectorized notation depvar(1,:),depvar(2,:),...,ctrl(1,:),ctrl(2,:),...
        % 3 user notation
        optmethod=optimizationmethod(ocStruct);
        subtype=dgsubtype(ocStruct);
        description='';
        for ii=1:size(optmethod,1)
            switch deblank(optmethod(ii,:))
                case 'bvp'
                    bvpdescription={'CanonicalSystem'; 2; ...
                        'SymbolicCanonicalSystem';3; ...
                        'SymbolicCanonicalSystemJacobian';3; ...
                        'SymbolicOptimalControl';3; ...
                        'SymbolicHamiltonian';3; ...
                        'SymbolicLagrangeMultiplier';3; ...
                        'EquilibriumEquation'; 2; ...
                        'EquilibriumEquationJacobian'; 1; ...
                        'EquilibriumEquationParameterJacobian'; 1; ...
                        'EquilibriumAdmissible';0; ...
                        'OptimalControl'; 2; ...
                        'LagrangeMultiplier'; 2; ...
                        'CanonicalSystemJacobian'; 1; ...
                        'CanonicalSystemParameterJacobian'; 1; ...
                        'Hamiltonian'; 2; ...
                        'DHamiltonianDu'; 1; ...
                        'Constraint'; 2; ...
                        'ObjectiveFunction';2; ...
                        'TransversalityBC';1; ...
                        'Admissible';0; ...
                        'UserFunction';2; ...
                        'DiscountedSalvagevalue';1; ...
                        'ObjectiveFunctionJacobian'; 1; ...
                        'ObjectiveFunctionParameterJacobian';1; ...
                        'ObjectiveFunctionDerivativeTime';2; ...
                        'PlotIndifferenceContinuation';0; ...
                        'PlotContinuation';0; ...
                        '4SaddlePathContinuation'; 1; ...
                        '4FiniteHorizonPathContinuation';1; ...
                        '4IndifferenceSolutionContinuation';1};
                    switch subtype
                        case 'cl'
                            rmidx=find(strcmp(bvpdescription,'CanonicalSystem'));
                            bvpdescription(rmidx:rmidx+1,:)=[];
                            rmidx=find(strcmp(bvpdescription,'EquilibriumEquation'));
                            bvpdescription(rmidx:rmidx+1,:)=[];
                            rmidx=find(strcmp(bvpdescription,'SymbolicCanonicalSystem'));
                            bvpdescription(rmidx:rmidx+1,:)=[];
                            bvpdescription=[bvpdescription; ...
                                'CrossCompetitionTerm';2; ...
                                'SymbolicAdjointSystem';3; ...
                                'SymbolicCanonicalSystem4cl';3; ...
                                'CanonicalSystem4cl';2; ...
                        'EquilibriumEquation4cl'; 2];
                    end
            end
        end

        if isempty(description)
            description=bvpdescription;
        else
            description=[description; ...
                bvpdescription];
        end
end
name=description(1:2:end-1);
transformtype=description(2:2:end);

modelfiles=struct('name',name,'transformtype',transformtype);
